<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SQL Query Builder</title>
<style>
  *{margin: 0;box-sizing:border-box; padding: 0;}  
  body{font-family:sans-serif, Verdana; background: linear-gradient(to right,#0b1220, #092d52); padding-inline-start: 100px; padding-top: 50px;}
  .headConteiner{ display: flex; align-items: center; gap: 20px;}
  .card{ display: flex; flex-direction: column; align-items: start; justify-content: center; gap: 10px; width: 95%; background: linear-gradient(to right,#ffffff,#898b96);padding:18px;border-radius:10px; box-shadow: #0c3f72 6px 12px 12px;;margin-bottom:16px;}
  textarea{width:80%;height:140px;padding:10px;font-family:monospace; display: block; margin-bottom: 20px;}
  pre{background:#0b1220;color:#dff7c8;padding:12px;border-radius:8px;white-space:pre-wrap;}
  input[type=file]{display:block;margin:8px 0}
  button{padding:10px 12px;border-radius:8px;border:0;background:#0b74de;color:#fff;cursor:pointer}
  small{color:#666}
  .articleConteiner{display:grid;grid-template-columns:1fr 1fr;}
  .buttonConteiner{display:flex;gap:12px;margin-top:10px;}
</style>
</head>
<body>
  <div class="headConteiner">
    <img src="image.png" alt="" style="width: 250px; height:auto; margin-bottom:20px; border-radius: 15px; box-shadow: #0c3f72 6px 6px 12px;">
    <h1 style="color: rgb(207, 212, 235);">SQL Select Query Builder</h1>
  </div>
<section class="articleConteiner">
  <article>
    <div class="card">
      <strong>1) Load Files</strong>
      <p><small>Select Ralationships json File</small><input type="file" id="relationsFile" accept="application/json"></p>  
      <p><small>Select Aliases json File</small><input type="file" id="aliasFile" accept="application/json"></p>
    </div>

      <div class="card">
        <strong>2) Paste alias to include (one per line, exactly as it appears on the ticket)</strong>
        <textarea style="width: 50%;" id="aliasList" placeholder="Example: Policy Number
         Postal Code
         INSURED_NAME"></textarea>
         <div class="buttonConteiner">
           <button id="generate">Generate Query</button>
           <button id="copyBtn" style="padding:10px 12px;border-radius:8px;border:0;background:#06818a;color:#fff;cursor:pointer">Copy Query</button>

         </div>
      </div>
  </article>
  <article>
    <div class="card">
      <strong> 3) Result (query)</strong>
      <pre id="output">The query will appear here...</pre>
      <details>
        <summary>Debug: tables detected / joins calculated</summary>
        <pre id="debug"></pre>
      </details>
    </div>
  </article>
</section>
<script>
let relationsRaw = null;
let aliasArray = null;

function sanitizeTableName(t) {
  if (!t) return t;
  // Dejar solo letras, números y guión bajo para evitar cualquier carácter problemático
  const cleaned = String(t).replace(/[^A-Za-z0-9_]/g, "");
  // Si quedó vacío (p. ej. el nombre solo tenía caracteres inválidos), devolvemos el original
  return cleaned || String(t);
}

// Parse the relations file format (expects objects {from,to,on})
function parseRelations(arr){
  return arr.map(r => {
    // r.on like "pc_account.ID=pc_address.Account"
    const on = (r.on || r.On || r.ON || '').trim();
    const parts = on.split('=');
    const left = parts[0] ? parts[0].trim() : null;
    const right = parts[1] ? parts[1].trim() : null;
    // attempt to extract table and column
    function splitFull(f){
      if(!f) return {table:null,column:null,raw:null};
      const idx = f.lastIndexOf('.');
      if(idx>0) return {table: f.slice(0,idx), column: f.slice(idx+1), raw: f};
      return {table: null, column: f, raw: f};
    }
    const L = splitFull(left);
    const R = splitFull(right);
    return {from: r.from, to: r.to, onRaw: on, leftTable: L.table, leftCol: L.column, rightTable: R.table, rightCol: R.column};
  });
}

function buildGraph(rels){
  const graph = {};
  rels.forEach(r => {
    if(!graph[r.from]) graph[r.from]=[];
    if(!graph[r.to]) graph[r.to]=[];
    graph[r.from].push({to: r.to, onRaw: r.onRaw, leftTable: r.leftTable, leftCol: r.leftCol, rightTable: r.rightTable, rightCol: r.rightCol, from: r.from});
    graph[r.to].push({to: r.from, onRaw: r.onRaw, leftTable: r.leftTable, leftCol: r.leftCol, rightTable: r.rightTable, rightCol: r.rightCol, from: r.from});
  });
  return graph;
}

// BFS path (returns array of table names path)
function findPath(graph, start, end){
  if(start===end) return [start];
  const queue = [[start]];
  const visited = new Set([start]);
  while(queue.length){
    const path = queue.shift();
    const node = path[path.length-1];
    const edges = graph[node] || [];
    for(const e of edges){
      if(visited.has(e.to)) continue;
      visited.add(e.to);
      const newPath = path.concat([e.to]);
      if(e.to === end) return newPath;
      queue.push(newPath);
    }
  }
  return null;
}

// For a path like [A,B,C] build join clauses using the relation 'onRaw' where possible
function joinsForPath(path, rels){
  const joins = [];
  const usedPairs = new Set();
  for(let i=0;i<path.length-1;i++){
    const a = path[i];
    const b = path[i+1];
    // find any relation object that connects a and b
    const rel = rels.find(r => (r.from===a && r.to===b) || (r.from===b && r.to===a));
    if(!rel){
      // no direct relation — skip (shouldn't happen if path comes from graph)
      continue;
    }
    // avoid duplicates
    const key = [a,b].sort().join('__');
    if(usedPairs.has(key)) continue;
    usedPairs.add(key);
    // Use the raw ON expression directly (it already contains fully-qualified table.column)
    // But ensure we join the "to" side table (b). We'll use LEFT JOIN to be safe.
    joins.push({joinTable: b, on: rel.onRaw, rawRel: rel});
  }
  return joins;
}

function buildSelectField(table, field, alias){
  // sanitize table name from alias JSON (handles weird values like "pc_job (Renewal)")
  const t = sanitizeTableName(table);
  if(!field) return `${t}.* AS [${alias}]`;

  // if field contains '+', treat as concatenation expression
  if(field.includes('+')){
    // split by + and wrap each token as table.col
    const parts = field.split('+').map(p=>p.trim());
    const mapped = parts.map(p => {
      // if p contains a space or parentheses, just leave it
      const col = p.match(/[A-Za-z0-9_]+/);
      if(col) return `${t}.${col[0]}`;
      return p;
    });
    return `${mapped.join(" + ")} AS [${alias}]`;
  }

  // simple column name or expression
  // if field already contains a dot, assume fully qualified
  if(field.includes('.')) return `${field} AS [${alias}]`;
  // else prefix with table
  return `${t}.${field} AS [${alias}]`;
}

function generateQuery(){
  if(!relationsRaw || !aliasArray){
    alert('You must load both the relations and alias JSON files first.');
    return;
  }

  const relsParsed = parseRelations(relationsRaw);
  const graph = buildGraph(relsParsed.map(r=>({from:r.from,to:r.to,onRaw:r.onRaw,leftTable:r.leftTable,leftCol:r.leftCol,rightTable:r.rightTable,rightCol:r.rightCol})));

  const aliases = document
  .getElementById('aliasList')
  .value
  .split(/\r?\n/)
  .map(s => s.trim())
  .filter(Boolean);

  const copyBtn = document.getElementById('copyBtn');
  copyBtn.addEventListener('click', () => {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text)
    .then(() => {
      copyBtn.textContent = '¡Copied!';
      setTimeout(()=> copyBtn.textContent = 'Copy Query', 1500);
    })
    .catch(err => alert('Error al copiar: ' + err));
});


  if(aliases.length===0){ alert('Pegá los alias a incluir'); return; }

  // build map alias -> {table, field}
  const aliasMap = {};
  aliasArray.forEach(a => { aliasMap[a.alias] = {table: a.table, field: a.field}; });

  const fieldsInfo = [];
  const tablesNeeded = new Set();
  aliases.forEach(al => {
    const info = aliasMap[al];
    if(!info){
      console.warn('Alias no encontrado en el JSON:', al);
      return;
    }
    const sanitizedTable = sanitizeTableName(info.table);
    fieldsInfo.push({alias: al, table: sanitizedTable, field: info.field});
    tablesNeeded.add(sanitizedTable);
  });

  const tables = Array.from(tablesNeeded);
  if(tables.length===0){ alert('No se encontraron alias válidos'); return; }

  // pick a base table heuristically: the one that appears most often in relations or the first requested
  function degree(t){
    return (graph[t]||[]).length;
  }
  tables.sort((a,b)=> degree(b)-degree(a));
  const base = tables[0];

  // compute joins by finding path from base to each other table
  const allJoins = [];
  const joinKeys = new Set();
  const errors = [];
  for(let i=1;i<tables.length;i++){
    const target = tables[i];
    const path = findPath(graph, base, target);
    if(!path){ errors.push(`No path from ${base} to ${target}`); continue; }
    const joins = joinsForPath(path, relsParsed.map(r=>({from:r.from,to:r.to,onRaw:r.onRaw,leftTable:r.leftTable,leftCol:r.leftCol,rightTable:r.rightTable,rightCol:r.rightCol})))
    joins.forEach(j => {
      const key = `${j.joinTable}::${j.on}`;
      if(!joinKeys.has(key)){
        joinKeys.add(key);
        allJoins.push(j);
      }
    });
  }

  // build SELECT clause
  const selectParts = fieldsInfo.map(f => buildSelectField(f.table, f.field, f.alias));

  // build FROM + JOIN SQL text
  const joinSqlLines = allJoins.map(j => `LEFT JOIN ${j.joinTable} ON ${j.on}\n  `);
  // formato con tabulado bonito
  const sql = `SELECT
    ${selectParts.join(',   \n    ')}
  FROM ${base}
  ${joinSqlLines.map(j => '  ' + j).join('')}${errors.length ? '  -- ERRORS: \n    -- ' + errors.join('\n    -- ') : ''}`; `SELECT
  ${selectParts.join(', \n ')}FROM ${base}${joinSqlLines.join('')}${errors.length? '-- ERRORS:-- '+errors.join('-- '): ''}`;

  document.getElementById('output').textContent = sql;

  // debug info
  const dbg = [];
  dbg.push('Detected Tables: '+tables.join(', '));
  dbg.push('\nBase Table: '+base);
  dbg.push('\n\nGenerated Joins:');
  allJoins.forEach(j=> dbg.push(` \n JOIN ${j.joinTable} ON ${j.on}`));
  if(errors.length) dbg.push('\n\nErrors Found:\n'+errors.join('\n'));
  document.getElementById('debug').textContent = dbg.join('');
}

// file inputs
document.getElementById('relationsFile').addEventListener('change', async e=>{
  const f = e.target.files[0];
  if(!f) return;
  try{
    relationsRaw = JSON.parse(await f.text());
    console.log('relaciones cargadas', relationsRaw.length);
  }catch(err){ alert('Error leyendo JSON de relaciones: '+err.message); }
});

document.getElementById('aliasFile').addEventListener('change', async e=>{
  const f = e.target.files[0];
  if(!f) return;
  try{
    aliasArray = JSON.parse(await f.text());
    console.log('alias cargados', aliasArray.length);
  }catch(err){ alert('Error leyendo JSON de alias: '+err.message); }
});

document.getElementById('generate').addEventListener('click', generateQuery);
</script>

</body>
</html>
